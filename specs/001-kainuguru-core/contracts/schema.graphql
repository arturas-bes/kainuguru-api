# Kainuguru GraphQL API Schema
# Generated: 2025-11-04
# Version: 1.0.0

scalar DateTime
scalar UUID
scalar JSON

# ==================== ENUMS ====================

enum Language {
  LT
  EN
}

enum FlyerStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum ExtractionStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  NEEDS_REVIEW
}

enum AvailabilityStatus {
  AVAILABLE
  UNAVAILABLE
  LIMITED
}

enum SortOrder {
  ASC
  DESC
}

enum ProductSortBy {
  PRICE_LOW
  PRICE_HIGH
  NAME
  DISCOUNT
  RELEVANCE
}

# ==================== TYPES ====================

type User {
  id: UUID!
  email: String!
  emailVerified: Boolean!
  fullName: String
  preferredLanguage: Language!
  createdAt: DateTime!
  lastLoginAt: DateTime
  shoppingLists: [ShoppingList!]!
  defaultShoppingList: ShoppingList
}

type Store {
  id: Int!
  code: String!
  name: String!
  logoUrl: String
  websiteUrl: String
  locations: [StoreLocation!]!
  currentFlyer: Flyer
  flyers(first: Int, after: String): FlyerConnection!
  isActive: Boolean!
}

type StoreLocation {
  lat: Float!
  lng: Float!
  address: String!
  city: String!
}

type Flyer {
  id: Int!
  store: Store!
  title: String
  validFrom: DateTime!
  validTo: DateTime!
  pageCount: Int!
  pages: [FlyerPage!]!
  products(
    first: Int
    after: String
    search: String
    category: String
    minPrice: Float
    maxPrice: Float
    sortBy: ProductSortBy
  ): ProductConnection!
  isArchived: Boolean!
  status: FlyerStatus!
  productsExtracted: Int!
  createdAt: DateTime!
}

type FlyerPage {
  id: Int!
  flyer: Flyer!
  pageNumber: Int!
  imageUrl: String
  extractionStatus: ExtractionStatus!
  needsManualReview: Boolean!
  products: [Product!]!
}

type Product {
  id: String! # Composite ID for partitioned table
  flyer: Flyer!
  store: Store!
  name: String!
  brand: String
  description: String
  priceCurrent: Float!
  priceOriginal: Float
  discountPercentage: Float
  unit: String
  quantity: Float
  category: String
  tags: [String!]!
  imageUrl: String
  validFrom: DateTime!
  validTo: DateTime!
  productMaster: ProductMaster
  matchingConfidence: Float
  priceHistory: [PricePoint!]!
}

type ProductMaster {
  id: Int!
  canonicalName: String!
  brand: String
  category: String
  typicalUnit: String
  barcode: String
  tags: [String!]!
  averagePrice: Float
  occurrenceCount: Int!
  lastSeenDate: DateTime
  currentProducts: [Product!]!
}

type PricePoint {
  date: DateTime!
  price: Float!
  store: Store!
}

type ShoppingList {
  id: UUID!
  name: String!
  description: String
  owner: User!
  isDefault: Boolean!
  isShared: Boolean!
  shareToken: String
  items: [ShoppingListItem!]!
  itemCount: Int!
  completedCount: Int!
  estimatedTotal: Float
  createdAt: DateTime!
  updatedAt: DateTime!
  lastUsedAt: DateTime
}

type ShoppingListItem {
  id: UUID!
  shoppingList: ShoppingList!
  product: Product
  productMaster: ProductMaster
  textDescription: String!
  quantity: Int!
  unit: String
  notes: String
  isChecked: Boolean!
  checkedAt: DateTime
  availabilityStatus: AvailabilityStatus!
  suggestedAlternatives: [Product!]!
  position: Int!
  currentPrice: Float
  bestPrice: ProductPrice
}

type ProductPrice {
  product: Product!
  store: Store!
  price: Float!
}

type SearchResult {
  products: [Product!]!
  totalCount: Int!
  facets: SearchFacets!
}

type SearchFacets {
  categories: [CategoryFacet!]!
  brands: [BrandFacet!]!
  stores: [StoreFacet!]!
  priceRanges: [PriceRangeFacet!]!
}

type CategoryFacet {
  category: String!
  count: Int!
}

type BrandFacet {
  brand: String!
  count: Int!
}

type StoreFacet {
  store: Store!
  count: Int!
}

type PriceRangeFacet {
  min: Float!
  max: Float!
  count: Int!
}

# ==================== CONNECTIONS ====================

type FlyerConnection {
  edges: [FlyerEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type FlyerEdge {
  node: Flyer!
  cursor: String!
}

type ProductConnection {
  edges: [ProductEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProductEdge {
  node: Product!
  cursor: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

# ==================== INPUTS ====================

input RegisterInput {
  email: String!
  password: String!
  fullName: String
  preferredLanguage: Language = LT
}

input LoginInput {
  email: String!
  password: String!
}

input UpdateUserInput {
  fullName: String
  preferredLanguage: Language
}

input CreateShoppingListInput {
  name: String!
  description: String
  isDefault: Boolean
}

input UpdateShoppingListInput {
  name: String
  description: String
  isDefault: Boolean
}

input AddShoppingListItemInput {
  shoppingListId: UUID!
  productId: String
  productMasterId: Int
  textDescription: String!
  quantity: Int = 1
  unit: String
  notes: String
}

input UpdateShoppingListItemInput {
  quantity: Int
  unit: String
  notes: String
  isChecked: Boolean
  position: Int
}

input SearchInput {
  query: String!
  storeIds: [Int!]
  categories: [String!]
  minPrice: Float
  maxPrice: Float
  onlyCurrentFlyers: Boolean = true
  includeArchived: Boolean = false
  limit: Int = 20
  offset: Int = 0
  sortBy: ProductSortBy = RELEVANCE
}

input RequestPasswordResetInput {
  email: String!
}

input ResetPasswordInput {
  token: String!
  newPassword: String!
}

# ==================== QUERIES ====================

type Query {
  # User queries (authenticated)
  me: User
  myShoppingLists: [ShoppingList!]!
  shoppingList(id: UUID!): ShoppingList
  sharedShoppingList(shareToken: String!): ShoppingList

  # Store queries (public)
  stores(onlyActive: Boolean = true): [Store!]!
  store(code: String!): Store

  # Flyer queries (public)
  currentFlyers: [Flyer!]!
  flyer(id: Int!): Flyer
  flyersByStore(
    storeCode: String!
    first: Int = 10
    after: String
  ): FlyerConnection!

  # Product queries (public)
  product(id: String!): Product
  productMaster(id: Int!): ProductMaster
  searchProducts(input: SearchInput!): SearchResult!

  # Price comparison (public)
  comparePrice(
    productMasterId: Int!
    storeIds: [Int!]
  ): [ProductPrice!]!

  # Product suggestions (public)
  suggestProducts(
    query: String!
    limit: Int = 5
  ): [ProductMaster!]!
}

# ==================== MUTATIONS ====================

type Mutation {
  # Authentication
  register(input: RegisterInput!): AuthPayload!
  login(input: LoginInput!): AuthPayload!
  logout: Boolean!
  refreshToken: AuthPayload!
  requestPasswordReset(input: RequestPasswordResetInput!): Boolean!
  resetPassword(input: ResetPasswordInput!): Boolean!
  verifyEmail(token: String!): Boolean!

  # User profile (authenticated)
  updateProfile(input: UpdateUserInput!): User!
  deleteAccount: Boolean!

  # Shopping lists (authenticated)
  createShoppingList(input: CreateShoppingListInput!): ShoppingList!
  updateShoppingList(
    id: UUID!
    input: UpdateShoppingListInput!
  ): ShoppingList!
  deleteShoppingList(id: UUID!): Boolean!
  shareShoppingList(id: UUID!): String! # Returns share token
  unshareShoppingList(id: UUID!): Boolean!

  # Shopping list items (authenticated)
  addShoppingListItem(input: AddShoppingListItemInput!): ShoppingListItem!
  updateShoppingListItem(
    id: UUID!
    input: UpdateShoppingListItemInput!
  ): ShoppingListItem!
  deleteShoppingListItem(id: UUID!): Boolean!
  checkShoppingListItem(id: UUID!, checked: Boolean!): ShoppingListItem!
  reorderShoppingListItems(
    listId: UUID!
    itemIds: [UUID!]!
  ): [ShoppingListItem!]!

  # Bulk operations (authenticated)
  addProductsToList(
    listId: UUID!
    productIds: [String!]!
  ): [ShoppingListItem!]!
  clearCheckedItems(listId: UUID!): Int! # Returns count of cleared items
}

# ==================== SUBSCRIPTIONS ====================

type Subscription {
  # Real-time flyer updates
  flyerUpdated(storeCode: String): Flyer!

  # Shopping list collaboration (authenticated)
  shoppingListUpdated(id: UUID!): ShoppingList!
  shoppingListItemUpdated(listId: UUID!): ShoppingListItem!
}

# ==================== AUTH PAYLOAD ====================

type AuthPayload {
  token: String!
  refreshToken: String!
  user: User!
  expiresIn: Int!
}

# ==================== ERROR TYPES ====================

type Error {
  message: String!
  code: String!
  field: String
}

# ==================== DIRECTIVES ====================

directive @auth on FIELD_DEFINITION
directive @rateLimit(
  limit: Int!
  duration: Int!
) on FIELD_DEFINITION