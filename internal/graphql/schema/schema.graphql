# Kainuguru GraphQL Schema
# Browse Weekly Grocery Flyers API

scalar Time
scalar JSON
scalar UUID

# Authentication Types
type User {
  id: UUID!
  email: String!
  emailVerified: Boolean!
  fullName: String
  preferredLanguage: String!
  isActive: Boolean!
  lastLoginAt: Time
  createdAt: Time!
  updatedAt: Time!
}

type AuthPayload {
  user: User!
  accessToken: String!
  refreshToken: String!
  expiresAt: Time!
  tokenType: String!
}

# Authentication Input Types
input RegisterInput {
  email: String!
  password: String!
  fullName: String
  preferredLanguage: String = "lt"
}

input LoginInput {
  email: String!
  password: String!
}

input UpdateUserInput {
  fullName: String
  preferredLanguage: String
}

input ChangePasswordInput {
  currentPassword: String!
  newPassword: String!
}

input RequestPasswordResetInput {
  email: String!
}

input ResetPasswordInput {
  token: String!
  newPassword: String!
}

# Store Types
type Store {
  id: Int!
  code: String!
  name: String!
  logoURL: String
  websiteURL: String
  flyerSourceURL: String
  locations: [StoreLocation!]!
  scraperConfig: JSON
  scrapeSchedule: String!
  lastScrapedAt: Time
  isActive: Boolean!
  createdAt: Time!
  updatedAt: Time!

  # Relations
  flyers(
    filters: FlyerFilters
    first: Int
    after: String
  ): FlyerConnection!
}

type StoreLocation {
  city: String!
  lat: Float!
  lng: Float!
  address: String!
}

# Flyer Types
type Flyer {
  id: Int!
  storeID: Int!
  title: String
  validFrom: Time!
  validTo: Time!
  pageCount: Int
  sourceURL: String
  isArchived: Boolean!
  archivedAt: Time
  status: FlyerStatus!
  extractionStartedAt: Time
  extractionCompletedAt: Time
  productsExtracted: Int!
  createdAt: Time!
  updatedAt: Time!

  # Computed fields
  isValid: Boolean!
  isCurrent: Boolean!
  daysRemaining: Int!
  validityPeriod: String!
  processingDuration: String

  # Relations
  store: Store!
  flyerPages(
    filters: FlyerPageFilters
    first: Int
    after: String
  ): FlyerPageConnection!
  products(
    filters: ProductFilters
    first: Int
    after: String
  ): ProductConnection!
}

enum FlyerStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

# Flyer Page Types
type FlyerPage {
  id: Int!
  flyerID: Int!
  pageNumber: Int!
  imageURL: String
  imageWidth: Int
  imageHeight: Int
  status: FlyerPageStatus!
  extractionStartedAt: Time
  extractionCompletedAt: Time
  productsExtracted: Int!
  extractionErrors: Int!
  lastExtractionError: String
  lastErrorAt: Time
  createdAt: Time!
  updatedAt: Time!

  # Computed fields
  hasImage: Boolean!
  imageDimensions: ImageDimensions
  processingDuration: String
  extractionEfficiency: Float!

  # Relations
  flyer: Flyer!
  products(
    filters: ProductFilters
    first: Int
    after: String
  ): ProductConnection!
}

enum FlyerPageStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

type ImageDimensions {
  width: Int!
  height: Int!
}

# Product Types
type Product {
  id: Int!
  flyerID: Int!
  flyerPageID: Int
  storeID: Int!
  productMasterID: Int
  name: String!
  normalizedName: String!
  brand: String
  category: String
  subcategory: String
  description: String
  currentPrice: Float!
  originalPrice: Float
  discountPercent: Float
  currency: String!
  unitSize: String
  unitType: String
  unitPrice: String
  packageSize: String
  weight: String
  volume: String
  imageURL: String
  boundingBox: ProductBoundingBox
  pagePosition: ProductPosition
  isOnSale: Boolean!
  saleStartDate: Time
  saleEndDate: Time
  isAvailable: Boolean!
  stockLevel: String
  extractionConfidence: Float!
  extractionMethod: String!
  requiresReview: Boolean!
  validFrom: Time!
  validTo: Time!
  createdAt: Time!
  updatedAt: Time!

  # Computed fields
  isCurrentlyOnSale: Boolean!
  discountAmount: Float!
  isValid: Boolean!
  isExpired: Boolean!
  validityPeriod: String!

  # Relations
  flyer: Flyer!
  flyerPage: FlyerPage
  store: Store!
  productMaster: ProductMaster
}

type ProductBoundingBox {
  x: Float!
  y: Float!
  width: Float!
  height: Float!
}

type ProductPosition {
  row: Int!
  column: Int!
  zone: String!
}

# Product Master Types
type ProductMaster {
  id: Int!
  canonicalName: String!
  normalizedName: String!
  brand: String!
  category: String!
  subcategory: String
  standardUnitSize: String
  standardUnitType: String
  standardPackageSize: String
  standardWeight: String
  standardVolume: String
  matchingKeywords: JSON!
  alternativeNames: JSON!
  exclusionKeywords: JSON!
  confidenceScore: Float!
  matchedProducts: Int!
  successfulMatches: Int!
  failedMatches: Int!
  status: ProductMasterStatus!
  isVerified: Boolean!
  lastMatchedAt: Time
  verifiedAt: Time
  verifiedBy: String
  createdAt: Time!
  updatedAt: Time!

  # Computed fields
  matchSuccessRate: Float!

  # Relations
  products(
    filters: ProductFilters
    first: Int
    after: String
  ): ProductConnection!
}

enum ProductMasterStatus {
  ACTIVE
  INACTIVE
  PENDING
  DUPLICATE
  DEPRECATED
}

# Shopping List Types
type ShoppingList {
  id: Int!
  userID: UUID!
  name: String!
  description: String
  isDefault: Boolean!
  isArchived: Boolean!
  isPublic: Boolean!
  shareCode: String
  itemCount: Int!
  completedItemCount: Int!
  estimatedTotalPrice: Float
  createdAt: Time!
  updatedAt: Time!
  lastAccessedAt: Time!

  # Computed fields
  completionPercentage: Float!
  isCompleted: Boolean!
  canBeShared: Boolean!

  # Relations
  user: User!
  items(
    filters: ShoppingListItemFilters
    first: Int
    after: String
  ): ShoppingListItemConnection!
  categories: [ShoppingListCategory!]!
}

type ShoppingListItem {
  id: Int!
  shoppingListID: Int!
  userID: UUID!
  description: String!
  normalizedDescription: String!
  notes: String
  quantity: Float!
  unit: String
  unitType: String
  isChecked: Boolean!
  checkedAt: Time
  checkedByUserID: UUID
  sortOrder: Int!
  productMasterID: Int
  linkedProductID: Int
  storeID: Int
  flyerID: Int
  estimatedPrice: Float
  actualPrice: Float
  priceSource: String
  category: String
  tags: [String!]!
  suggestionSource: String
  matchingConfidence: Float
  availabilityStatus: String!
  availabilityCheckedAt: Time
  createdAt: Time!
  updatedAt: Time!

  # Computed fields
  totalEstimatedPrice: Float!
  totalActualPrice: Float!
  isLinked: Boolean!

  # Relations
  shoppingList: ShoppingList!
  user: User!
  checkedByUser: User
  productMaster: ProductMaster
  linkedProduct: Product
  store: Store
  flyer: Flyer
}

type ShoppingListCategory {
  id: Int!
  shoppingListID: Int!
  userID: UUID!
  name: String!
  colorHex: String
  iconName: String
  sortOrder: Int!
  itemCount: Int!
  createdAt: Time!

  # Relations
  shoppingList: ShoppingList!
  user: User!
}

type ProductCategory {
  id: Int!
  name: String!
  normalizedName: String!
  parentID: Int
  displayNameLT: String!
  displayNameEN: String
  description: String
  iconName: String
  colorHex: String
  level: Int!
  sortOrder: Int!
  keywords: [String!]!
  excludedKeywords: [String!]!
  productCount: Int!
  usageCount: Int!
  isActive: Boolean!
  createdAt: Time!
  updatedAt: Time!

  # Relations
  parent: ProductCategory
  children: [ProductCategory!]!
}

type ProductTag {
  id: Int!
  name: String!
  normalizedName: String!
  displayNameLT: String!
  displayNameEN: String
  description: String
  colorHex: String
  tagType: String!
  isSystemTag: Boolean!
  usageCount: Int!
  isActive: Boolean!
  createdAt: Time!
  updatedAt: Time!
}

type UserTag {
  id: Int!
  userID: UUID!
  tagName: String!
  displayName: String
  colorHex: String
  usageCount: Int!
  lastUsedAt: Time
  createdAt: Time!

  # Relations
  user: User!
}

enum SuggestionSource {
  MANUAL
  FLYER
  PREVIOUS_ITEMS
  POPULAR
  AUTO_COMPLETE
}

enum PriceSource {
  FLYER
  USER_ESTIMATE
  HISTORICAL
  ACTUAL
}

enum AvailabilityStatus {
  AVAILABLE
  UNAVAILABLE
  UNKNOWN
  SEASONAL
}

enum UnitType {
  VOLUME
  WEIGHT
  COUNT
}

enum TagType {
  GENERAL
  DIETARY
  ALLERGEN
  QUALITY
  SEASONAL
}

# Shopping List Connection Types
type ShoppingListConnection {
  edges: [ShoppingListEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ShoppingListEdge {
  node: ShoppingList!
  cursor: String!
}

type ShoppingListItemConnection {
  edges: [ShoppingListItemEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ShoppingListItemEdge {
  node: ShoppingListItem!
  cursor: String!
}

type ProductCategoryConnection {
  edges: [ProductCategoryEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProductCategoryEdge {
  node: ProductCategory!
  cursor: String!
}

type ProductTagConnection {
  edges: [ProductTagEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProductTagEdge {
  node: ProductTag!
  cursor: String!
}

# Shopping List Input Types
input CreateShoppingListInput {
  name: String!
  description: String
  isDefault: Boolean = false
}

input UpdateShoppingListInput {
  name: String
  description: String
  isDefault: Boolean
}

input ShoppingListFilters {
  isDefault: Boolean
  isArchived: Boolean
  isPublic: Boolean
  hasItems: Boolean
  createdAfter: Time
  createdBefore: Time
  updatedAfter: Time
  updatedBefore: Time
}

input CreateShoppingListItemInput {
  shoppingListID: Int!
  description: String!
  notes: String
  quantity: Float = 1
  unit: String
  unitType: String
  category: String
  tags: [String!] = []
  estimatedPrice: Float
  productMasterID: Int
  linkedProductID: Int
  storeID: Int
}

input UpdateShoppingListItemInput {
  description: String
  notes: String
  quantity: Float
  unit: String
  unitType: String
  category: String
  tags: [String!]
  estimatedPrice: Float
  actualPrice: Float
}

input ShoppingListItemFilters {
  isChecked: Boolean
  categories: [String!]
  tags: [String!]
  hasPrice: Boolean
  isLinked: Boolean
  storeIDs: [Int!]
  createdAfter: Time
  createdBefore: Time
}

input BulkItemOperationInput {
  itemIDs: [Int!]!
}

input ReorderItemsInput {
  listID: Int!
  itemOrders: [ItemOrderInput!]!
}

input ItemOrderInput {
  itemID: Int!
  sortOrder: Int!
}

input ProductMatchFilters {
  storeIDs: [Int!]
  categories: [String!]
  brands: [String!]
  minConfidence: Float
  onlyAvailable: Boolean = false
  onlyOnSale: Boolean = false
  priceRange: PriceRangeInput
}

input PriceRangeInput {
  min: Float
  max: Float
}

input CategoryFilters {
  parentID: Int
  level: Int
  isActive: Boolean
}

input TagFilters {
  tagType: [TagType!]
  isSystem: Boolean
  isActive: Boolean
}

# Response Types
type ShoppingListStats {
  totalItems: Int!
  completedItems: Int!
  completionRate: Float!
  estimatedTotal: Float
  categoriesUsed: Int!
  tagsUsed: Int!
  lastUpdated: Time!
  averageItemPrice: Float
  linkedItemsCount: Int!
  unlinkedItemsCount: Int!
}

type ItemSuggestion {
  description: String!
  source: String!
  productMaster: ProductMaster
  product: Product
  estimatedPrice: Float
  confidence: Float!
}

type ProductMatch {
  product: Product!
  productMaster: ProductMaster
  confidence: Float!
  priceMatch: Boolean!
  brandMatch: Boolean!
  sizeMatch: Boolean!
}

type AutoMatchResult {
  itemID: Int!
  item: ShoppingListItem!
  match: ProductMatch
  success: Boolean!
  reason: String!
}

type SmartSuggestion {
  type: String!
  productMaster: ProductMaster!
  reason: String!
  confidence: Float!
  estimatedPrice: Float
}

# Connection Types for Pagination
type StoreConnection {
  edges: [StoreEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type StoreEdge {
  node: Store!
  cursor: String!
}

type FlyerConnection {
  edges: [FlyerEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type FlyerEdge {
  node: Flyer!
  cursor: String!
}

type FlyerPageConnection {
  edges: [FlyerPageEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type FlyerPageEdge {
  node: FlyerPage!
  cursor: String!
}

type ProductConnection {
  edges: [ProductEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProductEdge {
  node: Product!
  cursor: String!
}

type ProductMasterConnection {
  edges: [ProductMasterEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProductMasterEdge {
  node: ProductMaster!
  cursor: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

# Filter Input Types
input StoreFilters {
  isActive: Boolean
  hasFlyers: Boolean
  codes: [String!]
}

input FlyerFilters {
  storeIDs: [Int!]
  storeCodes: [String!]
  status: [FlyerStatus!]
  isArchived: Boolean
  validFrom: Time
  validTo: Time
  isCurrent: Boolean
  isValid: Boolean
}

input FlyerPageFilters {
  flyerIDs: [Int!]
  status: [FlyerPageStatus!]
  hasImage: Boolean
  hasProducts: Boolean
  pageNumbers: [Int!]
}

input ProductFilters {
  storeIDs: [Int!]
  flyerIDs: [Int!]
  flyerPageIDs: [Int!]
  productMasterIDs: [Int!]
  categories: [String!]
  brands: [String!]
  isOnSale: Boolean
  isAvailable: Boolean
  requiresReview: Boolean
  minPrice: Float
  maxPrice: Float
  currency: String
  validFrom: Time
  validTo: Time
}

input ProductMasterFilters {
  status: [ProductMasterStatus!]
  isVerified: Boolean
  isActive: Boolean
  categories: [String!]
  brands: [String!]
  minMatches: Int
  minConfidence: Float
}

# Query Root
type Query {
  # Authentication Queries (require auth)
  me: User

  # Store Queries
  store(id: Int!): Store
  storeByCode(code: String!): Store
  stores(
    filters: StoreFilters
    first: Int
    after: String
  ): StoreConnection!

  # Flyer Queries
  flyer(id: Int!): Flyer
  flyers(
    filters: FlyerFilters
    first: Int
    after: String
  ): FlyerConnection!

  # Current and Valid Flyers (Main Browse Feature)
  currentFlyers(
    storeIDs: [Int!]
    first: Int
    after: String
  ): FlyerConnection!

  validFlyers(
    storeIDs: [Int!]
    first: Int
    after: String
  ): FlyerConnection!

  # Flyer Page Queries
  flyerPage(id: Int!): FlyerPage
  flyerPages(
    filters: FlyerPageFilters
    first: Int
    after: String
  ): FlyerPageConnection!

  # Product Queries
  product(id: Int!): Product
  products(
    filters: ProductFilters
    first: Int
    after: String
  ): ProductConnection!

  # Product Search
  searchProducts(
    query: String!
    filters: ProductFilters
    first: Int
    after: String
  ): ProductConnection!

  # Advanced Product Search
  advancedSearchProducts(
    input: AdvancedSearchInput!
  ): AdvancedSearchResponse!

  # Fuzzy Product Search
  fuzzySearchProducts(
    input: FuzzySearchInput!
  ): FuzzySearchResponse!

  # Hybrid Product Search
  hybridSearchProducts(
    input: HybridSearchInput!
  ): HybridSearchResponse!

  # Search Suggestions
  searchSuggestions(
    input: SearchSuggestionsInput!
  ): SearchSuggestionsResponse!

  # Similar Products
  similarProducts(
    input: SimilarProductsInput!
  ): SimilarProductsResponse!

  # Query Corrections
  queryCorrections(
    input: QueryCorrectionsInput!
  ): QueryCorrectionsResponse!

  # Search Health
  searchHealth: SearchHealthResponse!

  # Products on Sale
  productsOnSale(
    storeIDs: [Int!]
    filters: ProductFilters
    first: Int
    after: String
  ): ProductConnection!

  # Product Master Queries
  productMaster(id: Int!): ProductMaster
  productMasters(
    filters: ProductMasterFilters
    first: Int
    after: String
  ): ProductMasterConnection!

  # Shopping List Queries (require auth)
  shoppingList(id: Int!): ShoppingList
  shoppingLists(
    filters: ShoppingListFilters
    first: Int
    after: String
  ): ShoppingListConnection!

  sharedShoppingList(shareCode: String!): ShoppingList
  myDefaultShoppingList: ShoppingList
  myShoppingListStats: ShoppingListStats!

  # Shopping List Item Queries (require auth)
  shoppingListItem(id: Int!): ShoppingListItem
  shoppingListItems(
    listID: Int!
    filters: ShoppingListItemFilters
    first: Int
    after: String
  ): ShoppingListItemConnection!

  # Item suggestions and matching
  suggestItems(
    query: String!
    limit: Int = 10
  ): [ItemSuggestion!]!

  findMatchingProducts(
    description: String!
    filters: ProductMatchFilters
  ): [ProductMatch!]!

  smartSuggestions(
    listID: Int!
    limit: Int = 10
  ): [SmartSuggestion!]!

  # Category and Tag Queries
  productCategories(
    filters: CategoryFilters
    first: Int
    after: String
  ): ProductCategoryConnection!

  productTags(
    filters: TagFilters
    first: Int
    after: String
  ): ProductTagConnection!

  myUserTags: [UserTag!]!

  myShoppingListCategories(listID: Int!): [ShoppingListCategory!]!

  # Price History Queries
  priceHistory(
    productID: Int!
    storeID: Int
    filters: PriceHistoryFilters
    first: Int
    after: String
  ): PriceHistoryConnection!

  priceHistoryByDateRange(
    productID: Int!
    startDate: Time!
    endDate: Time!
    storeIDs: [Int!]
  ): [PriceHistory!]!

  currentPrice(productID: Int!, storeID: Int): PriceHistory
  currentPrices(productID: Int!, storeIDs: [Int!]): [PriceHistory!]!

  # Price Analysis Queries
  analyzeTrend(
    productID: Int!
    period: String! # "7_days", "30_days", "90_days", "1_year"
    storeID: Int
  ): TrendAnalysis

  compareStoreTrends(
    productID: Int!
    storeIDs: [Int!]!
    period: String!
  ): StoreTrendComparison

  predictPrice(
    productID: Int!
    daysAhead: Int!
  ): PricePrediction

  buyingRecommendation(productID: Int!): BuyingRecommendation

  priceAlertSuggestions(productID: Int!): PriceAlertSuggestions

  trendSummary(productID: Int!): TrendSummary

  seasonalTrends(productID: Int!): SeasonalTrendAnalysis

  # Price Alert Queries (require auth)
  priceAlert(id: ID!): PriceAlert
  priceAlerts(
    filters: PriceAlertFilters
    first: Int
    after: String
  ): PriceAlertConnection!

  myPriceAlerts: [PriceAlert!]!
  activePriceAlerts: [PriceAlert!]!
}

# Search Input Types
input AdvancedSearchInput {
  query: String!
  storeIDs: [Int!]
  minPrice: Float
  maxPrice: Float
  onSaleOnly: Boolean = false
  category: String
  limit: Int = 50
  offset: Int = 0
  preferFuzzy: Boolean = false
}

input FuzzySearchInput {
  query: String!
  storeIDs: [Int!]
  minPrice: Float
  maxPrice: Float
  category: String
  limit: Int = 50
  offset: Int = 0
  similarityThreshold: Float = 0.3
}

input HybridSearchInput {
  query: String!
  storeIDs: [Int!]
  minPrice: Float
  maxPrice: Float
  limit: Int = 50
  offset: Int = 0
  preferFuzzy: Boolean = false
}

input SearchSuggestionsInput {
  partialQuery: String!
  limit: Int = 10
}

input SimilarProductsInput {
  productID: Int!
  limit: Int = 10
}

input QueryCorrectionsInput {
  query: String!
  limit: Int = 5
}

# Search Response Types
type AdvancedSearchResponse {
  products: [ProductSearchResult!]!
  totalCount: Int!
  queryTime: String!
  suggestions: [String!]
  hasMore: Boolean!
}

type FuzzySearchResponse {
  products: [FuzzyProductResult!]!
  totalCount: Int!
  queryTime: String!
  hasMore: Boolean!
}

type HybridSearchResponse {
  products: [HybridProductResult!]!
  totalCount: Int!
  queryTime: String!
  hasMore: Boolean!
}

type ProductSearchResult {
  product: Product!
  searchScore: Float!
  matchType: String!
  similarity: Float
  highlights: [String!]
}

type FuzzyProductResult {
  product: Product!
  searchScore: Float!
  nameSimilarity: Float!
  brandSimilarity: Float!
  combinedSimilarity: Float!
}

type HybridProductResult {
  product: Product!
  searchScore: Float!
  matchType: String!
}

type SearchSuggestionsResponse {
  suggestions: [SearchSuggestion!]!
}

type SearchSuggestion {
  text: String!
  frequency: Int!
  minPrice: Float!
  maxPrice: Float!
  storeCount: Int!
}

type SimilarProductsResponse {
  products: [SimilarProduct!]!
}

type SimilarProduct {
  product: Product!
  similarityScore: Float!
}

type QueryCorrectionsResponse {
  corrections: [QueryCorrection!]!
}

type QueryCorrection {
  suggestion: String!
  confidence: Float!
}

type SearchHealthResponse {
  indexStatus: [SearchIndexStatus!]!
  lastRefreshTime: Time!
  suggestionCount: Int!
  averageQueryTime: String!
  totalSearches: Int!
  errorRate: Float!
}

type SearchIndexStatus {
  indexName: String!
  isHealthy: Boolean!
  isUsed: Boolean!
}

# Mutation Root
type Mutation {
  # Authentication Mutations
  register(input: RegisterInput!): AuthPayload!
  login(input: LoginInput!): AuthPayload!
  logout: Boolean!
  refreshToken: AuthPayload!

  # User Management (require auth)
  updateProfile(input: UpdateUserInput!): User!
  changePassword(input: ChangePasswordInput!): Boolean!

  # Password Reset
  requestPasswordReset(input: RequestPasswordResetInput!): Boolean!
  resetPassword(input: ResetPasswordInput!): Boolean!

  # Email Verification
  verifyEmail(token: String!): Boolean!
  resendEmailVerification: Boolean!

  # Search Management
  refreshSearchSuggestions: RefreshSearchSuggestionsResponse!

  # Shopping List Mutations (require auth)
  createShoppingList(input: CreateShoppingListInput!): ShoppingList!
  updateShoppingList(id: Int!, input: UpdateShoppingListInput!): ShoppingList!
  deleteShoppingList(id: Int!): Boolean!
  archiveShoppingList(id: Int!): ShoppingList!
  unarchiveShoppingList(id: Int!): ShoppingList!
  setDefaultShoppingList(id: Int!): ShoppingList!
  generateShareCode(id: Int!): ShoppingList!
  disableSharing(id: Int!): ShoppingList!
  duplicateShoppingList(id: Int!, newName: String!): ShoppingList!
  clearCompletedItems(id: Int!): ShoppingList!

  # Shopping List Item Mutations (require auth)
  createShoppingListItem(input: CreateShoppingListItemInput!): ShoppingListItem!
  updateShoppingListItem(id: Int!, input: UpdateShoppingListItemInput!): ShoppingListItem!
  deleteShoppingListItem(id: Int!): Boolean!
  checkShoppingListItem(id: Int!): ShoppingListItem!
  uncheckShoppingListItem(id: Int!): ShoppingListItem!

  # Bulk operations
  bulkCheckItems(input: BulkItemOperationInput!): [ShoppingListItem!]!
  bulkUncheckItems(input: BulkItemOperationInput!): [ShoppingListItem!]!
  bulkDeleteItems(input: BulkItemOperationInput!): Boolean!
  reorderItems(input: ReorderItemsInput!): [ShoppingListItem!]!

  # Item matching and suggestions
  matchItemToProduct(itemID: Int!, productID: Int!): ShoppingListItem!
  matchItemToProductMaster(itemID: Int!, productMasterID: Int!): ShoppingListItem!
  autoMatchItem(itemID: Int!): AutoMatchResult!
  batchAutoMatchItems(listID: Int!): [AutoMatchResult!]!

  # Category and tag management
  createShoppingListCategory(
    listID: Int!
    name: String!
    colorHex: String
    iconName: String
  ): ShoppingListCategory!

  updateShoppingListCategory(
    id: Int!
    name: String
    colorHex: String
    iconName: String
  ): ShoppingListCategory!

  deleteShoppingListCategory(id: Int!): Boolean!

  # Price Alert Mutations (require auth)
  createPriceAlert(input: CreatePriceAlertInput!): PriceAlert!
  updatePriceAlert(id: ID!, input: UpdatePriceAlertInput!): PriceAlert!
  deletePriceAlert(id: ID!): Boolean!
  activatePriceAlert(id: ID!): PriceAlert!
  deactivatePriceAlert(id: ID!): PriceAlert!
  resetPriceAlertTriggerCount(id: ID!): PriceAlert!

  # Placeholder mutations for future implementation
  _placeholder: Boolean
}

type RefreshSearchSuggestionsResponse {
  success: Boolean!
  refreshedAt: Time!
  suggestionCount: Int!
}

# Price History Types
type PriceHistory {
  id: ID!
  productID: Int!
  storeID: Int!
  flyerID: Int
  price: Float!
  originalPrice: Float
  currency: String!
  isOnSale: Boolean!
  recordedAt: Time!
  validFrom: Time!
  validTo: Time!
  saleStartDate: Time
  saleEndDate: Time
  source: String!
  extractionMethod: String!
  confidence: Float!
  isAvailable: Boolean!
  stockLevel: String
  notes: String
  isActive: Boolean!
  createdAt: Time!

  # Computed fields
  isCurrentlyValid: Boolean!
  isCurrentlySale: Boolean!
  discountAmount: Float!
  discountPercent: Float!
  isExpired: Boolean!
  validityDuration: String!

  # Relations
  product: Product!
  store: Store!
  flyer: Flyer
}

type PriceTrend {
  id: ID!
  productID: Int!
  storeID: Int
  period: String!
  startDate: Time!
  endDate: Time!
  calculatedAt: Time!
  direction: TrendDirection!
  trendPercent: Float!
  confidence: Float!
  dataPoints: Int!
  volatilityScore: Float!
  startPrice: Float!
  endPrice: Float!
  minPrice: Float!
  maxPrice: Float!
  avgPrice: Float!
  medianPrice: Float!
  slope: Float!
  intercept: Float!
  rSquared: Float!
  isSignificant: Boolean!
  ma7: Float!
  ma14: Float!
  ma30: Float!
  isActive: Boolean!
  createdAt: Time!
  updatedAt: Time!

  # Computed fields
  isUpTrend: Boolean!
  isDownTrend: Boolean!
  isStable: Boolean!
  isVolatile: Boolean!
  trendStrength: String!
  isCurrentTrend: Boolean!

  # Relations
  product: Product!
  store: Store
}

enum TrendDirection {
  RISING
  FALLING
  STABLE
  VOLATILE
}

type PriceAlert {
  id: ID!
  userID: Int!
  productID: Int!
  storeID: Int
  alertType: AlertType!
  targetPrice: Float!
  dropPercent: Float
  isActive: Boolean!
  notifyEmail: Boolean!
  notifyPush: Boolean!
  lastTriggered: Time
  triggerCount: Int!
  lastPrice: Float
  notes: String
  createdAt: Time!
  updatedAt: Time!
  expiresAt: Time

  # Computed fields
  isActiveAlert: Boolean!

  # Relations
  user: User!
  product: Product!
  store: Store
}

enum AlertType {
  PRICE_DROP
  TARGET_PRICE
  PERCENTAGE_DROP
}

# Price Analysis Types
type TrendAnalysis {
  productID: Int!
  period: String!
  direction: TrendDirection!
  trendPercentage: Float!
  confidence: Float!
  startPrice: Float!
  endPrice: Float!
  averageChange: Float!
  volatilityScore: Float!
  dataPoints: Int!
  linearRegression: RegressionData!
  movingAverages: MovingAverages!
  trendStrength: String!
}

type RegressionData {
  slope: Float!
  intercept: Float!
  rSquared: Float!
  pValue: Float!
  significant: Boolean!
}

type MovingAverages {
  ma7: Float!
  ma14: Float!
  ma30: Float!
  ma7AboveMa30: Boolean!
}

type StoreTrendComparison {
  productID: Int!
  storeTrends: [StoreTrend!]!
  bestStore: StoreTrend
  worstStore: StoreTrend
  divergence: Float!
}

type StoreTrend {
  storeID: Int!
  storeName: String!
  trendAnalysis: TrendAnalysis!
  currentPrice: Float!
  priceStability: Float!
}

type PricePrediction {
  productID: Int!
  predictionDate: Time!
  predictedPrice: Float!
  confidenceInterval: ConfidenceInterval!
  methodology: String!
  accuracy: Float!
  factors: [PredictionFactor!]!
}

type ConfidenceInterval {
  lower: Float!
  upper: Float!
  confidence: Float!
}

type PredictionFactor {
  name: String!
  impact: Float!
  description: String!
}

type BuyingRecommendation {
  productID: Int!
  recommendation: RecommendationType!
  currentPrice: Float!
  recommendedAction: String!
  confidence: Float!
  reasoning: [String!]!
  nextSaleDate: Time
  potentialSavings: Float!
  waitDays: Int!
}

enum RecommendationType {
  BUY_NOW
  WAIT
  MONITOR
}

type PriceAlertSuggestions {
  productID: Int!
  currentPrice: Float!
  thresholds: [AlertThreshold!]!
  historicalStats: HistoricalStats!
}

type AlertThreshold {
  level: String!
  price: Float!
  frequency: String!
  lastSeen: Time!
  description: String!
}

type HistoricalStats {
  averagePrice: Float!
  medianPrice: Float!
  percentile10: Float!
  percentile25: Float!
  percentile75: Float!
  percentile90: Float!
}

type TrendSummary {
  productID: Int!
  shortTermTrend: TrendAnalysis
  mediumTermTrend: TrendAnalysis
  longTermTrend: TrendAnalysis
  buyingAdvice: BuyingRecommendation
  priceAlerts: PriceAlertSuggestions
  seasonalPattern: SeasonalTrendAnalysis
  keyInsights: [String!]!
}

type SeasonalTrendAnalysis {
  productID: Int!
  hasSeasonality: Boolean!
  seasonalIndex: Float!
  seasons: [SeasonalPeriod!]!
  nextPeakSeason: SeasonalPeriod
  nextLowSeason: SeasonalPeriod
  recommendations: [SeasonalAdvice!]!
}

type SeasonalPeriod {
  season: String!
  startMonth: Int!
  endMonth: Int!
  avgPrice: Float!
  priceIndex: Float!
  nextStart: Time!
}

type SeasonalAdvice {
  period: String!
  advice: String!
  potentialSavings: Float!
  timing: String!
}

# Price History Connections
type PriceHistoryConnection {
  edges: [PriceHistoryEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PriceHistoryEdge {
  node: PriceHistory!
  cursor: String!
}

# Price Alert Connections
type PriceAlertConnection {
  edges: [PriceAlertEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PriceAlertEdge {
  node: PriceAlert!
  cursor: String!
}

# Input Types for Price History
input PriceHistoryFilters {
  productID: Int
  storeID: Int
  startDate: Time
  endDate: Time
  isOnSale: Boolean
  minPrice: Float
  maxPrice: Float
  source: String
}

input PriceAlertFilters {
  productID: Int
  storeID: Int
  alertType: AlertType
  isActive: Boolean
}

input CreatePriceAlertInput {
  productID: Int!
  storeID: Int
  alertType: AlertType!
  targetPrice: Float!
  dropPercent: Float
  notifyEmail: Boolean = true
  notifyPush: Boolean = false
  notes: String
  expiresAt: Time
}

input UpdatePriceAlertInput {
  targetPrice: Float
  dropPercent: Float
  isActive: Boolean
  notifyEmail: Boolean
  notifyPush: Boolean
  notes: String
  expiresAt: Time
}